# See bottom of file for license and copyright information

package Foswiki::ExtensionsTests::SampleClass;
use utf8;

use Foswiki::Class;
extends qw(Foswiki::Object);

has allowFlowControl => (
    is      => 'rw',
    default => 0,
);

sub testPluggableMethod {
    my $this = shift;

    return wantarray
      ? ( qw(This is a sample return array), @_ )
      : "This is a sample string {" . join( "}{", @_ ) . "}";
}

package ExtensionsTests;

use Assert;
use Foswiki::Exception  ();
use Foswiki::ExtManager ();
use Data::Dumper;

use Foswiki::FeatureSet;

use version 0.77;

use Foswiki::Class;
extends qw(FoswikiFnTestCase);

$| = 1;

# List of all auto generated extension modules.
has autoGenExt => (
    is        => 'rw',
    lazy      => 1,
    predicate => 1,
    default   => sub { [] },
);

around set_up => sub {
    my $orig = shift;
    my $this = shift;

    my $mKey = ( grep { /ExtensionsTests/ } keys %INC )[0];
    $ENV{FOSWIKI_EXTLIBS} =
      File::Spec->catdir( ( File::Spec->splitpath( $INC{$mKey} ) )[1],
        'TestExtensions' );

    # Disable all extensions generated by previous tests.
    _addExtToDisabled( @{ $this->autoGenExt } );

    $orig->( $this, @_ );

    my $cfgData = $this->app->cfg->data;
    delete @{ $cfgData->{ExtOrder} }{qw<First Last>};
    $cfgData->{DisableAllPlugins} = 1;
};

around tear_down => sub {
    my $orig = shift;
    my $this = shift;

    # Disable any extensions a test has generated.
    $this->_disableAllCurrentExtensions;

    $this->reCreateFoswikiApp;

    return $orig->( $this, @_ );
};

sub _getExtName {
    my $this = shift;

    state $idx = 0;

    return sprintf( 'Foswiki::Extension::Ext::Auto%04d', $idx++ );
}

sub _ext2IdxMap {
    my $this = shift;
    my @exts = @_;

    my $idx = 0;
    return ( map { $_ => $idx++ } @exts );
}

sub _extList2Idx {
    my $this = shift;
    my ( $exts, $extList ) = @_;

    my %idxMap = $this->_ext2IdxMap(@$exts);
    return [ map { $idxMap{$_} } @$extList ];
}

sub _genExtModules {
    my $this = shift;
    my ( $count, @extCode ) = @_;

    ASSERT($count);

    my @extNames;
    for ( 1 .. $count ) {
        my $extName = $this->_getExtName;
        my $code    = shift @extCode // '';
        my $ret     = eval <<EXT;
package $extName;
use Assert;
use Foswiki::Class -extension;
extends qw(Foswiki::Extension);

use version 0.77; our \$VERSION = version->declare(0.0.1);
our \$API_VERSION = version->declare("2.99.0");

Foswiki::ExtManager::_registerExtModule('$extName');

$code

1;
EXT
        unless ($ret) {
            Foswiki::Exception::Fatal->throw(
                text => "Extension module cannot be generated: "
                  . Foswiki::Exception::errorStr($@) );
        }
        push @extNames, $extName;
    }

    # Remember what extensions have been autogenerated.
    push @{ $this->autoGenExt }, @extNames;

    return @extNames;
}

sub _setExtDependencies {
    my $this = shift;
    my %deps = @_;

    foreach my $relation ( keys %deps ) {
        foreach my $extName ( keys %{ $deps{$relation} } ) {
            my $dep = $deps{$relation}{$extName};
            Foswiki::ExtManager::registerRelation( $relation, $extName,
                ref($dep) ? $dep : [$dep] );
        }
    }
}

sub _addExtToDisabled {
    $ENV{FOSWIKI_DISABLED_EXTENSIONS} =
      join( ",", ( split /,/, $ENV{FOSWIKI_DISABLED_EXTENSIONS} || '' ), @_ );
}

sub _disableAllCurrentExtensions {
    my $this = shift;

    #_addExtToDisabled(@Foswiki::ExtManager::extModules);
    $this->app->extMgr->disableExtension( $_, "Obsoleted test extensions" )
      foreach @Foswiki::ExtManager::extModules;
}

sub test_orderedList {
    my $this = shift;

    $this->_disableAllCurrentExtensions;

    my @ext = $this->_genExtModules(10);
    $this->_setExtDependencies(
        after => {
            $ext[0] => [ $ext[2], $ext[4] ],
            $ext[2] => $ext[3],
            $ext[3] => $ext[6],
        },
    );
    $this->reCreateFoswikiApp;

    #say STDERR "ORDER SIMPLE:",
    #  join( ",",
    #    @{ $this->_extList2Idx( \@ext, $this->app->extMgr->orderedList ) } );

    my $expected = [ 6, 3, 2, 4, 0, 1, 5, 7, 8, 9 ];

    $this->assert_deep_equals(
        $expected,
        $this->_extList2Idx( \@ext, $this->app->extMgr->orderedList ),
        "Simple ordering failed"
    );

    # Now add requirements

    $this->_setExtDependencies( require => { $ext[3] => $ext[5], }, );
    $this->reCreateFoswikiApp;

    $expected = [ 5, 6, 3, 2, 4, 0, 1, 7, 8, 9 ];

    #say STDERR "ORDER WITH REQ:",
    #  join( ",",
    #    @{ $this->_extList2Idx( \@ext, $this->app->extMgr->orderedList ) } );

    $this->assert_deep_equals(
        $expected,
        $this->_extList2Idx( \@ext, $this->app->extMgr->orderedList ),
        "Ordering with 'require' relations failed"
    );

    $this->app->cfg->data->{ExtOrder}{First} = join( "  , ", @ext[ 9, 2, 7 ] );
    $this->reCreateFoswikiApp;

    $expected = [ 9, 5, 6, 3, 2, 7, 4, 0, 1, 8 ];

    #say STDERR "ORDER WITH REQ AND USERDEF:",
    #  join( ",",
    #    @{ $this->_extList2Idx( \@ext, $this->app->extMgr->orderedList ) } );

    $this->assert_deep_equals(
        $expected,
        $this->_extList2Idx( \@ext, $this->app->extMgr->orderedList ),
        "Ordering with 'require' relations and user-defined priorities failed"
    );
}

sub test_manual_disable {
    my $this = shift;

    $this->_disableAllCurrentExtensions;

    my @ext = $this->_genExtModules(2);

    _addExtToDisabled( $ext[1] );

    $this->reCreateFoswikiApp;

    $this->assert_not_null(
        $this->app->extMgr->extensions->{ $ext[0] },
        "First extension is expected to be initialized"
    );
    $this->assert( !$this->app->extMgr->extEnabled( $ext[1] ),
        "Second extensions is expected to be disabled but it is not" );
    $this->assert_str_equals(
"Disable reason: listed in environment variable FOSWIKI_DISABLED_EXTENSIONS.",
        $this->app->extMgr->disabledExtensions->{ $ext[1] }
    );
}

sub test_depend_on_manual_disable {
    my $this = shift;

    $this->_disableAllCurrentExtensions;

    my @ext = $this->_genExtModules(4);

    _addExtToDisabled( $ext[1] );
    $this->_setExtDependencies(
        require => {
            $ext[3] => $ext[2],
            $ext[2] => $ext[1],
        }
    );

    $this->reCreateFoswikiApp;

    #say STDERR "ORDER:",
    #  join( ",",
    #    @{ $this->_extList2Idx( \@ext, $this->app->extMgr->orderedList ) } );

    #say STDERR "First ext: ", $ext[0];
    #say STDERR Dumper( $this->app->extMgr->requirements );

    $this->assert_not_null(
        $this->app->extMgr->extensions->{ $ext[0] },
        "First extension is expected to be initialized"
    );
    $this->assert( !$this->app->extMgr->extEnabled( $ext[1] ),
        "Second extension is expected to be disabled but it is not" );
    $this->assert_str_equals(
"Disable reason: listed in environment variable FOSWIKI_DISABLED_EXTENSIONS.",
        $this->app->extMgr->disabledExtensions->{ $ext[1] }
    );
    $this->assert( !$this->app->extMgr->extEnabled( $ext[2] ),
        "Third extension is expected to be disabled but it is not" );
    $this->assert( !$this->app->extMgr->extEnabled( $ext[3] ),
        "Fourth extension is expected to be disabled but it is not" );

    $this->assert_matches(
        qr/Required Foswiki::Extension::Ext::Auto\d+ is disabled/,
        $this->app->extMgr->disabledExtensions->{ $ext[2] }
    );

    $this->assert_matches(
        qr/Required Foswiki::Extension::Ext::Auto\d+ is disabled/,
        $this->app->extMgr->disabledExtensions->{ $ext[3] }
    );
}

sub test__preSortOrder {
    my $this = shift;

    # Do disable/recreate twice to make sure we have some junk extensions
    # disabled.
    $this->_disableAllCurrentExtensions;
    $this->_genExtModules(5);
    $this->reCreateFoswikiApp;

    $this->_disableAllCurrentExtensions;
    my @ext = $this->_genExtModules(10);
    $this->_setExtDependencies(
        after   => { $ext[1] => $ext[2], },
        require => {
            $ext[5] => [ $ext[3], $ext[2] ],
            $ext[7] => $ext[9],
        },
    );
    $this->reCreateFoswikiApp;

    my $preSorted = $this->app->extMgr->_preSortExts(@ext);

    #say STDERR "DISABLED LIST:", $ENV{FOSWIKI_DISABLED_EXTENSIONS};
    #say STDERR "BASE EXT:",      $ext[0];
    #say STDERR "PRE-SORTED ORDER:",
    #  join( ",", @{ $this->_extList2Idx( \@ext, $preSorted ) } );
    #say STDERR join( ",", @$preSorted );

    my $expected = [ 5, 7, 0, 1, 2, 3, 4, 6, 8, 9 ];
    $this->assert_deep_equals(
        $expected,
        $this->_extList2Idx( \@ext, $preSorted ),
        "Wrong pre-sorted order"
    );

}

sub test_circular_deps {
    my $this = shift;

    $this->_disableAllCurrentExtensions;

    my @ext = $this->_genExtModules(10);
    $this->_setExtDependencies(
        after => {
            $ext[1] => $ext[0],
            $ext[3] => $ext[2],
            $ext[2] => [ $ext[1], $ext[7] ],
            $ext[4] => $ext[3],
            $ext[5] => $ext[4],
            $ext[6] => $ext[5],
            $ext[7] => [ $ext[6], $ext[8] ],
            $ext[8] => $ext[9],
        },
    );

    #say STDERR "BASE:", $ext[0];

    $this->reCreateFoswikiApp;

    my $expected = [ 0, 1, 3, 4, 5, 6, 9, 8, 7, 2 ];

    #say STDERR "ORDER:",
    #  join( ",",
    #    @{ $this->_extList2Idx( \@ext, $this->app->extMgr->orderedList ) } );

    $this->assert_deep_equals(
        $expected,
        $this->_extList2Idx( \@ext, $this->app->extMgr->orderedList ),
        "Wrong order of extensions"
    );
}

sub test_circular_requirements {
    my $this = shift;

    $this->_disableAllCurrentExtensions;

    my @ext = $this->_genExtModules(8);
    $this->_setExtDependencies(
        after => {
            $ext[1] => $ext[0],
            $ext[6] => $ext[5],
            $ext[7] => $ext[6],
            $ext[5] => $ext[7],
        },
        require => {
            $ext[3] => $ext[2],
            $ext[4] => $ext[3],
            $ext[2] => $ext[4],
        },
    );

    $this->reCreateFoswikiApp;

    my $extMgr = $this->app->extMgr;

    foreach my $dIdx ( 2, 3, 4 ) {
        $this->assert(
            $extMgr->disabledExtensions->{ $ext[$dIdx] },
            "Extension #"
              . $dIdx
              . " is expected to be disabled due to circular dependency"
        );
        $this->assert_str_contains(
            "circular dependency of 'require' relations",
            $extMgr->disabledExtensions->{ $ext[$dIdx] },
        );
    }

    foreach my $eIdx ( 5, 6, 7 ) {
        $this->assert(
            !$extMgr->disabledExtensions->{ $ext[$eIdx] },
            "Extension #" . $eIdx . " is expected to be enabled"
        );
    }
}

sub test_loose_circular_requirements {
    my $this = shift;

    $this->_disableAllCurrentExtensions;
    my @ext = $this->_genExtModules(10);

    #say STDERR "BASE:", $ext[0];

    # Two loops:
    # 0 <- 1 <- 2 <- 3 -> 8
    #           v    ^    v
    #           7    4 <- 9
    #           v    ^
    #           6 -> 5
    #
    # Note that 4->3 is 'after', the rest is 'require'. This is where the cycle
    # will be broken.
    $this->_setExtDependencies(
        after   => { $ext[4] => $ext[3], },
        require => {
            $ext[8] => $ext[9],
            $ext[5] => $ext[4],
            $ext[7] => $ext[6],
            $ext[1] => $ext[0],
            $ext[2] => [ $ext[1], $ext[7] ],
            $ext[3] => [ $ext[8], $ext[2] ],
            $ext[6] => $ext[5],
            $ext[9] => $ext[4],
        }
    );
    $this->reCreateFoswikiApp;

    my $expected = [ 0, 1, 4, 5, 6, 7, 2, 9, 8, 3 ];

    $this->assert_deep_equals(
        $expected,
        $this->_extList2Idx( \@ext, $this->app->extMgr->orderedList ),
        "Wrong order of extensions"
    );

    # Now add one more loop by requiring 2 by 5. This must effectively disable
    # 2,7,6,5, and 3 as dependant on 2.
    $this->_setExtDependencies( require => { $ext[5] => $ext[2], }, );

    $this->reCreateFoswikiApp;

    $expected = [ 0, 1, 4, 9, 8 ];

    $this->assert_deep_equals(
        $expected,
        $this->_extList2Idx( \@ext, $this->app->extMgr->orderedList ),
        "Wrong order of extensions with a small loop"
    );

    # Big 'require' loop with 4->3 being 'after' :
    # 0 <- 1 <- 2 <- 3 <- 8
    #           v    ^    ^
    #           7    4 -> 9
    #           v    ^
    #           6 -> 5
    $this->_disableAllCurrentExtensions;
    @ext = $this->_genExtModules(10);
    $this->_setExtDependencies(
        after   => { $ext[4] => $ext[3], },
        require => {
            $ext[1] => $ext[0],
            $ext[2] => [ $ext[1], $ext[7] ],
            $ext[3] => $ext[2],
            $ext[4] => $ext[9],
            $ext[5] => $ext[4],
            $ext[6] => $ext[5],
            $ext[7] => $ext[6],
            $ext[8] => $ext[3],
            $ext[9] => $ext[8],
        }
    );
    $this->reCreateFoswikiApp;

    #say STDERR "ORDER         :",
    #  join( ",",
    #    @{ $this->_extList2Idx( \@ext, $this->app->extMgr->orderedList ) } );

    $expected = [ 0, 1 ];
    $this->assert_deep_equals(
        $expected,
        $this->_extList2Idx( \@ext, $this->app->extMgr->orderedList ),
        "Wrong order of extensions with a big loop"
    );

}

sub test_pluggable_methods {
    my $this = shift;

    $this->_disableAllCurrentExtensions;

    # Generate 3 extensions.
    my @ext = $this->_genExtModules(
        3,

        # First extension body
        <<'EXT1',
plugBefore 'Foswiki::ExtensionsTests::SampleClass::testPluggableMethod' => sub {
    my $this = shift;
    my ($params) = @_;
    
    # We expect at least two parameters to be passed in.
    $params->{args}[1] = "ext1ArgFromBefore";
};
EXT1

        # Second extension body
        <<'EXT2',
plugAround 'Foswiki::ExtensionsTests::SampleClass::testPluggableMethod' => sub {
    my $this = shift;
    my ($params) = @_;
    
    # Only if flow control is allowed by the calling test code.
    if ($params->{object}->allowFlowControl) {
        my $rc = 'ext2ReturnFromAround';
        if ( $params->{wantarray} ) {
            $params->{rc} = [$rc];
        }
        elsif ( defined $params->{wantarray} ) {
            $params->{rc} .= ($params->{rc} ? " " : "") . $rc;
        }
        
        delete $params->{ext3Flag1};
        
        Foswiki::Exception::Ext::Last->throw(
                rc => $params->{rc},
                extension => $this,
        );
    }
};

EXT2

        # Third extension body
        <<'EXT3',
plugBefore 'Foswiki::ExtensionsTests::SampleClass::testPluggableMethod' => sub {
    my $this = shift;
    my ($params) = @_;
    
    $params->{ext3Flag1} = 1;
    $params->{ext3Flag2} = 1;
};

plugAfter 'Foswiki::ExtensionsTests::SampleClass::testPluggableMethod' => sub {
    my $this = shift;
    my ($params) = @_;
    
    foreach my $flag (qw(ext3Flag1 ext3Flag2)) {
        if ($params->{$flag}) {
            my $rc = "with_$flag";
            if ($params->{wantarray}) {
                push @{$params->{rc}}, $rc;
            }
            elsif (defined $params->{wantarray}) {
                $params->{rc} .= " $rc";
            }
        }
    }
};
EXT3
    );
    $this->_setExtDependencies(
        after => {
            $ext[2] => $ext[1],
            $ext[1] => $ext[0],
        },
    );

    $this->reCreateFoswikiApp;

    my $testClass  = 'Foswiki::ExtensionsTests::SampleClass';
    my $testMethod = 'testPluggableMethod';
    $this->assert(
        defined $Foswiki::ExtManager::pluggables{$testClass}{$testMethod},
        "Method "
          . $testMethod
          . " of class "
          . $testClass
          . " is not registered as pluggable!"
    );

    my $testObj = $this->create('Foswiki::ExtensionsTests::SampleClass');

    my @args;
    @args = qw(arg1 arg2);
    my $rc = $testObj->testPluggableMethod(@args);

    $this->assert_str_equals(
'This is a sample string {arg1}{ext1ArgFromBefore} with_ext3Flag1 with_ext3Flag2',
        $rc
    );

    @args = qw(arg1 arg2);
    my @rc = $testObj->testPluggableMethod(@args);

    $this->assert_deep_equals(
        [
            qw(This is a sample return array arg1 ext1ArgFromBefore with_ext3Flag1 with_ext3Flag2)
        ],
        \@rc
    );

    $testObj->allowFlowControl(1);
    @args = qw(arg1 arg2);
    $rc   = $testObj->testPluggableMethod(@args);

    $this->assert_str_equals( 'ext2ReturnFromAround with_ext3Flag2', $rc );

    @args = qw(arg1 arg2);
    @rc   = $testObj->testPluggableMethod(@args);

    $this->assert_deep_equals( [qw(ext2ReturnFromAround with_ext3Flag2)],
        [@rc] );
}

sub test_API_VERSION {
    my $this = shift;

    $this->_disableAllCurrentExtensions;

    my @ext = $this->_genExtModules(2);
    my $ns0 = Foswiki::getNS( $ext[0] );

    *{ $ns0->{API_VERSION} } = \version->declare("v2.98.0");

    $this->reCreateFoswikiApp;

    ASSERT(
        !$this->app->extMgr->extEnabled( $ext[0] ),
        "Extension with API version "
          . Foswiki::fetchGlobal("\$$ext[0]::API_VERSION")
          . " must have been disabled but it's not"
    );

    ASSERT(
        $this->app->extMgr->extEnabled( $ext[1] ),
        "Extension with API version "
          . Foswiki::fetchGlobal("\$$ext[1]::API_VERSION")
          . " must have been enabled but it's not"
    );
}

sub test_FS_REQUIRED {
    my $this = shift;

    $this->_disableAllCurrentExtensions;

    features_provided
      GLOBAL_TEST => [ undef, undef, undef ],
      -namespace  => "ExtensionsTests",
      TEST1       => [ undef, undef, undef ],
      TEST2       => [ 2.0,   2.99,  4.0 ],
      TEST3       => [ 3.1,   undef, undef ],
      ;

    my @ext = $this->_genExtModules(
        8,

        # First extension body
        <<'EXT1',
# This will pass
our @FS_REQUIRED = qw(MOO UNICODE);
EXT1

        # Second extension
        <<'EXT2',
# This must fail
our @FS_REQUIRED = qw(MOO MISSING_FEATURE);
EXT2

        # Third extension
        <<'EXT3',
# Must pass
our @FS_REQUIRED = qw(MOO -namespace ExtensionsTests TEST1 TEST2);
EXT3

        # Fourth extension
        <<'EXT4',
# Must fail
our @FS_REQUIRED = qw(-namespace ExtensionsTests TEST1 TEST3);
EXT4

        # Fifth extension
        <<'EXT5',
# Must fail due to missing namespace name
our @FS_REQUIRED = qw(MOO UNICODE -namespace);
EXT5

        # Sixth extension
        <<'EXT6',
# Must fail due to no features in namespace
our @FS_REQUIRED = qw(MOO UNICODE -namespace ExtensionsTests);
EXT6

        # Seventh extension
        <<'EXT7',
# No @FS_REQUIRED, must pass
EXT7

        # Eighth extension
        <<'EXT8',
# Empty @FS_REQUIRED, must pass
our @FS_REQUIRED = ();
EXT8
    );

    my @expect = (
        undef,
        "Inactive or missing features: MISSING_FEATURE",
        undef,
        "Inactive or missing features: TEST3 from namespace ExtensionsTests",
        'Incomplete @FS_REQUIRED: no name defined for the last -namespace',
'Incomplete @FS_REQUIRED: empty list of features for -namespace ExtensionsTests',
        undef,
        undef,
    );

    $this->reCreateFoswikiApp;

    my $exts = $this->app->extMgr;

    foreach my $i ( 0 .. 7 ) {
        my $expect = defined( $expect[$i] )        ? "disabled" : "enabled";
        my $got    = $exts->extEnabled( $ext[$i] ) ? "enabled"  : "disabled";
        $this->assert_equals( $expect, $got,
                "Module #"
              . ( $i + 1 ) . " is "
              . $got
              . " but expected to be "
              . $expect );
        if ( $expect[$i] ) {
            my $reason = $exts->disabledExtensions->{ $ext[$i] };
            $this->assert_equals( $expect[$i], $reason,
                    "Module #"
                  . ( $i + 1 )
                  . " has failed as expected but with wrong reason:"
                  . "\n  * Expected: "
                  . $expect[$i]
                  . "\n  * Got     : "
                  . $reason );
        }
    }
}

sub test_subClassing {
    my $this = shift;

    $this->_disableAllCurrentExtensions;

    my $configExt = $this->_genExtModules( 1, <<'CFG_EXT');

extClass 'Foswiki::Config' => 'Foswiki::Extension::Sample::Config';
    
CFG_EXT

    $this->reCreateFoswikiApp;

    $this->assert(
        ref( $Foswiki::cfg{'.version'} ) eq 'version',
        "Config key '.version' is expected to be a version object"
    );
    $this->assert_equals(
        $Foswiki::Extension::Sample::Config::VERSION,
        $Foswiki::cfg{'.version'},
        "Config key '.version' returned unexpected version number"
    );

    my $testKey = "_ThisKeyMustNotBeUsed";
    $Foswiki::cfg{$testKey} = my $testVal =
      "Число пі дорівнює 3.1415926";
    $this->assert_equals( $testVal, $this->app->cfg->data->{$testKey},
"Value stored to %Foswiki::cfg doesn't match with fetched from application object cfg attribute"
    );
}

sub test_tag_handlers {
    my $this = shift;

    $this->_disableAllCurrentExtensions;

    # Testing three macros registered by the same extension using three
    # different approaches:
    #   1. A macro to be handled by an extension method with the same name as
    #      macro's.
    #   2. Similar to above but method code is declared as tagHandler's second
    #      parameter.
    #   3. A macro class with Foswiki::Macro role.
    # All three are refering the same extension object and it's autoincementing
    # counter attribute. But as long as the first two approaches are extension's
    # methods and rely upon valid $this parameter the class is obtaining
    # extension's object by requesting application's extensions attribute.

    my ($ext) = $this->_genExtModules( 1, <<'TAGH');
    
has counter => (
    is => 'rw',
    lazy => 1,
    default => 0,
);

around counter => sub {
    my $orig = shift;
    my $this = shift;
    my $val = $orig->($this);
    $orig->( $this, $val + 1 );
    return sprintf( '%03d', $val );
};

tagHandler 'TEST_EXT_MACRO1';

tagHandler TEST_EXT_MACRO2 => sub {
    my $this = shift;
    
    return 'TEST_EXT_MACRO2_' . $this->counter;
};

tagHandler TEST_CLASS_MACRO => 'Foswiki::Macros::TEST_CLASS_MACRO';

sub TEST_EXT_MACRO1 {
    my $this = shift;
    return "TEST_EXT_MACRO1_" . $this->counter;
}
TAGH

    my $macroPackage = <<MPKG;
package Foswiki::Macros::TEST_CLASS_MACRO;
    use Foswiki::Class -app;
    extends qw(Foswiki::Object);
    with qw(Foswiki::Macro);

    sub expand {
        my \$this = shift;

        my \$myExt = \$this->app->extMgr->extObject('$ext');

        return "TEST_CLASS_MACRO_" . \$myExt->counter;
    }
1;
MPKG

    if ( !eval($macroPackage) || $@ ) {
        Foswiki::Exception::Fatal->throw(
            text => "Failed to compile macro class: " . $@ );
    }

    $this->reCreateFoswikiApp;

    $this->test_topicObject->text('%TEST_EXT_MACRO1%');

    $this->assert_str_equals( 'TEST_EXT_MACRO1_000',
        $this->test_topicObject->expandMacros('%TEST_EXT_MACRO1%') );
    $this->assert_str_equals( 'TEST_EXT_MACRO1_001',
        $this->test_topicObject->expandMacros('%TEST_EXT_MACRO1%') );
    $this->assert_str_equals( 'TEST_CLASS_MACRO_002',
        $this->test_topicObject->expandMacros('%TEST_CLASS_MACRO%') );
    $this->assert_str_equals( 'TEST_EXT_MACRO2_003',
        $this->test_topicObject->expandMacros('%TEST_EXT_MACRO2%') );
}

sub test_extName_method {
    my $this = shift;

    $this->_disableAllCurrentExtensions;

    my ($ext) = $this->_genExtModules( 1, <<'SNEXT');
our $NAME = "AutoGenExt";
SNEXT

    $this->reCreateFoswikiApp;

    $this->assert_str_equals( 'AutoGenExt', $this->app->extMgr->extName($ext) );
}

sub test_callbacks {
    my $this = shift;

    $this->_disableAllCurrentExtensions;

    my $cbTestClassName = 'Foswiki::Extension::Test::CBTest';
    my $cbTestClass     = <<CBMOD;
package $cbTestClassName;

use Foswiki::Class -callbacks;
extends qw(Foswiki::Object);

callbackNames qw(LongEnoughNotToMakeAConflict);

sub sampleSingleCallBack {
    my \$this = shift;
    
    my \$cbParam = {
        param1 => 'This is param1',
        param2 => 3.14,
        param3 => 'І ще трохи, на пробу',
    };
    
    \$this->callback('LongEnoughNotToMakeAConflict', \$cbParam);
    
    return \$cbParam->{rcIExpect} // '*unexpected undef*';
}

sub sampleCBChain {
    my \$this = shift;
    
    my \$cbParam = {
        param1 => 'This is param1',
        param2 => 3.14,
        param3 => 'І ще трохи, на пробу',
    };
    
    my \$cbReturn = \$this->callback('LongEnoughNotToMakeAConflict', \$cbParam);
    
    return {
        rc => \$cbParam->{rcIExpect},
        cbReturn => \$cbReturn,
    };
}

1;
CBMOD

    if ( !eval($cbTestClass) || $@ ) {
        Foswiki::Exception::Fatal->throw(
            text => "Failed to compile callbacks test class: " . $@ );
    }

    my @ext = $this->_genExtModules( 1, <<EXT);
callbackHandler LongEnoughNotToMakeAConflict => sub {
    my \$this = shift;
    my (\$obj, \$params) = \@_;
    
    ASSERT(defined \$obj, "Callback initiator is not defined");
    ASSERT(\$obj->isa('$cbTestClassName' ),
      "Callback initiator of a wrong class" );

    \$params->{rcIExpect} =
        \$params->{param3}
      . ' щоб не був повний '
      . \$params->{param2} . '-ць';
};
EXT

    $this->reCreateFoswikiApp;

    my $cbObj = $this->create($cbTestClassName);

    my $rc = $cbObj->sampleSingleCallBack;

    $this->assert_str_equals(
'І ще трохи, на пробу щоб не був повний 3.14-ць',
        $rc
    );

    $this->_disableAllCurrentExtensions;

    @ext = $this->_genExtModules( 3, <<EXT1, <<EXT2, <<EXT3);
    
callbackHandler LongEnoughNotToMakeAConflict => sub {
    my \$this = shift;
    my (\$obj, \$params) = \@_;
    
    \$params->{rcIExpect} = 'This is from ext1';
};
EXT1

has beTheHighlander => ( is => 'rw', default => 0, );

callbackHandler LongEnoughNotToMakeAConflict => sub {
    my \$this = shift;
    Foswiki::Exception::Ext::Last->throw(
        extension => \$this,
        rc => 'This is from ext2',
    ) if \$this->beTheHighlander;
};
EXT2

callbackHandler LongEnoughNotToMakeAConflict => sub {
    my \$this = shift;
    my (\$obj, \$params) = \@_;
    
    \$params->{rcIExpect} = 'А це вже з ext3';
};
EXT3

    $this->_setExtDependencies(
        after => {
            $ext[1] => $ext[0],
            $ext[2] => $ext[1],
        }
    );

    $this->reCreateFoswikiApp;

    $rc = $cbObj->sampleCBChain;

    $this->assert( ref($rc) eq 'HASH',
        "sampleCBChain did not return hashref?" );
    $this->assert_str_equals( 'А це вже з ext3', $rc->{rc} );
    $this->assert_null( $rc->{cbReturn},
        "The callback call must have returned undef" );

    $this->app->extMgr->extObject( $ext[1] )->beTheHighlander(1);

    $rc = $cbObj->sampleCBChain;

    $this->assert( ref($rc) eq 'HASH',
        "sampleCBChain did not return hashref?" );
    $this->assert_str_equals( 'This is from ext1', $rc->{rc} );
    $this->assert_not_null( $rc->{cbReturn},
        "The callback call must have returned a value from exception" );
    $this->assert_str_equals( $rc->{cbReturn}, 'This is from ext2' );
}

sub test_override {
    my $this = shift;

    # Test plugs for methods without pluggable modifier.
    $this->_disableAllCurrentExtensions;

    my $pClass = "Foswiki::Extension::Sample::PlugOverrideTest";

    my $rcStr = "This is plug for public";

    my @ext = $this->_genExtModules(
        1,
        <<EXT,
plugAround "${pClass}::publicMethod" => sub {
    my \$this = shift;
    my (\$params) = \@_;
    
    \$params->{rc} = "$rcStr";
};
EXT
    );

    $this->reCreateFoswikiApp;

    my $obj = $this->create($pClass);

    $this->assert_equals( $obj->publicMethod, $rcStr );
}

sub test_badOverrides {
    my $this = shift;

    # Test for disabling extensions where plugs failed for any reason.
    $this->_disableAllCurrentExtensions;

    my $goodClass = "Foswiki::Extension::Sample::PlugOverrideTest";
    my $badClass  = "Foswiki::Extension::Sample::BadPlugOverrideTest";

    my $rcStr = "we must not get this";

    my @ext = $this->_genExtModules(
        2,

        # This extensions must be disabled because plugging into invalid method.
        <<EXT1,
plugAround "${goodClass}::nonExistingMethod" => sub {
    my \$this = shift;
    my (\$params) = \@_;
    
    \$params->{rc} = "$rcStr";
};
EXT1

        # This one must be disabled because the module contains a syntax error.
        <<EXT2,
plugAround "${badClass}::badMethod" => sub {
    my \$this = shift;
    my (\$params) = \@_;
    
    \$params->{rc} = "$rcStr";
};
EXT2
    );

    $this->reCreateFoswikiApp;

    my $app = $this->app;

    $this->assert(
        !$app->extMgr->extEnabled( $ext[0] ),
"Extension must have been disabled because of plugging into non-existing method"
    );
    $this->assert(
        !$app->extMgr->extEnabled( $ext[1] ),
"Extension must have been disabled because of plugging into non-compilable module"
    );
}

1;
__END__
Foswiki - The Free and Open Source Wiki, http://foswiki.org/

Copyright (C) 2016 Foswiki Contributors. Foswiki Contributors
are listed in the AUTHORS file in the root of this distribution.
NOTE: Please extend that file, not this notice.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version. For
more details read LICENSE in the root of this distribution.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

As per the GPL, removal of this notice is prohibited.
