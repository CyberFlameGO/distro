# See bottom of file for license and copyright information

package Foswiki::ExtensionsTests::SampleClass;

use Foswiki::Class qw(extensible);
extends qw(Foswiki::Object);

has allowFlowControl => (
    is      => 'rw',
    default => 0,
);

pluggable testPluggableMethod => sub {
    my $this = shift;

    return wantarray
      ? ( qw(This is a sample return array), @_ )
      : "This is a sample string {" . join( "}{", @_ ) . "}";
};

package ExtensionsTests;

use Assert;
use Foswiki::Exception ();

use version 0.77;

use Foswiki::Class;
extends qw(FoswikiFnTestCase);

$| = 1;

# List of all auto generated extension modules.
has autoGenExt => (
    is        => 'rw',
    lazy      => 1,
    predicate => 1,
    default   => sub { [] },
);

around set_up => sub {
    my $orig = shift;
    my $this = shift;

    my $mKey = ( grep { /ExtensionsTests/ } keys %INC )[0];
    $ENV{FOSWIKI_EXTLIBS} =
      File::Spec->catdir( ( File::Spec->splitpath( $INC{$mKey} ) )[1],
        'TestExtensions' );

    # Disable all extensions generated by previous tests.
    $ENV{FOSWIKI_DISABLED_EXTENSIONS} = join ",", @{ $this->autoGenExt };

    $orig->( $this, @_ );

    $this->app->cfg->data->{DisableAllPlugins} = 1;
};

around tear_down => sub {
    my $orig = shift;
    my $this = shift;

    # Disable any extensions a test has generated.
    $this->_disableAllCurrentExtensions;

    $this->reCreateFoswikiApp;

    return $orig->( $this, @_ );
};

sub _getExtName {
    my $this = shift;

    state $idx = 0;

    return sprintf( 'Foswiki::Extension::Ext::Auto%04d', $idx++ );
}

sub _genExtModules {
    my $this = shift;
    my ( $count, @extCode ) = @_;

    ASSERT($count);

    my @extNames;
    for ( 1 .. $count ) {
        my $extName = $this->_getExtName;
        my $code    = shift @extCode // '';
        my $ret     = eval <<EXT;
package $extName;
use Foswiki::Class qw(extension);
extends qw(Foswiki::Extension);

use version 0.77; our \$VERSION = version->declare(0.0.1);
our \$API_VERSION = version->declare("2.99.0");

Foswiki::Extensions::registerExtModule('$extName');

$code

1;
EXT
        unless ($ret) {
            Foswiki::Exception::Fatal->throw(
                text => "Extension module cannot be generated: "
                  . Foswiki::Exception::errorStr($@) );
        }
        push @extNames, $extName;
    }

    # Remember what extensions have been autogenerated.
    push @{ $this->autoGenExt }, @extNames;

    return @extNames;
}

sub _setExtDependencies {
    my $this = shift;
    my %deps = @_;

    foreach my $extName ( keys %deps ) {
        my $dep = $deps{$extName};
        Foswiki::Extensions::registerDeps( $extName,
            ref($dep) ? @{$dep} : $dep );
    }
}

sub _disableAllCurrentExtensions {
    my $this = shift;
    $this->app->env->{FOSWIKI_DISABLED_EXTENSIONS} =
      [@Foswiki::Extensions::extModules];
}

sub test_orderedList {
    my $this = shift;

    # First disable all previously loaded extensions.
    $this->_disableAllCurrentExtensions;

    my @ext = $this->_genExtModules(4);
    $this->_setExtDependencies(
        $ext[0] => $ext[2],
        $ext[2] => $ext[3],
        $ext[3] => $ext[1],
    );
    $this->reCreateFoswikiApp;

    my $expected = [ @ext[ 1, 3, 2, 0 ] ];

    $this->assert_deep_equals(
        $expected,
        $this->app->extensions->orderedList,
        "Wrong order of extensions"
    );
}

sub test_manual_disable {
    my $this = shift;

    $this->_disableAllCurrentExtensions;

    my @ext = $this->_genExtModules(2);

    push @{ $this->app->env->{FOSWIKI_DISABLED_EXTENSIONS} }, $ext[1];

    $this->reCreateFoswikiApp;

    $this->assert_not_null(
        $this->app->extensions->extensions->{ $ext[0] },
        "First extension is expected to be initialized"
    );
    $this->assert( !$this->app->extensions->extEnabled( $ext[1] ),
        "Second extensions is expected to be disabled but it is not" );
    $this->assert_str_equals(
        "Disabled by FOSWIKI_DISABLED_EXTENSIONS environment variable.",
        $this->app->extensions->disabledExtensions->{ $ext[1] }
    );
}

sub test_depend_on_manual_disable {
    my $this = shift;

    $this->_disableAllCurrentExtensions;

    my @ext = $this->_genExtModules(4);

    push @{ $this->app->env->{FOSWIKI_DISABLED_EXTENSIONS} }, $ext[1];
    $this->_setExtDependencies(
        $ext[3] => $ext[2],
        $ext[2] => $ext[1],
    );

    $this->reCreateFoswikiApp;

    $this->assert_not_null(
        $this->app->extensions->extensions->{ $ext[0] },
        "First extension is expected to be initialized"
    );
    $this->assert( !$this->app->extensions->extEnabled( $ext[1] ),
        "Second extensions is expected to be disabled but it is not" );
    $this->assert_str_equals(
        "Disabled by FOSWIKI_DISABLED_EXTENSIONS environment variable.",
        $this->app->extensions->disabledExtensions->{ $ext[1] }
    );
    $this->assert(
        !$this->app->extensions->extEnabled( $ext[2] ),
        "Third extensions is expected to be disabled but it is not"
    );
    $this->assert( !$this->app->extensions->extEnabled( $ext[3] ),
        "Fourth extensions is expected to be disabled but it is not" );

    $this->assert_str_contains( "Disabled extension",
        $this->app->extensions->disabledExtensions->{ $ext[2] } );

    $this->assert_str_contains( "Disabled extension",
        $this->app->extensions->disabledExtensions->{ $ext[3] } );
}

sub test_circular_deps {
    my $this = shift;

    $this->_disableAllCurrentExtensions;

    my @ext = $this->_genExtModules(4);
    $this->_setExtDependencies(
        $ext[0] => $ext[2],
        $ext[3] => $ext[1],
        $ext[1] => $ext[3],
    );
    $this->reCreateFoswikiApp;

    my $expected = [ @ext[ 2, 0 ] ];

    $this->assert_deep_equals(
        $expected,
        $this->app->extensions->orderedList,
        "Wrong order of extensions"
    );

    $this->assert_str_contains( "Circular dependecy found for ",
        $this->app->extensions->disabledExtensions->{ $ext[1] } );

    $this->assert_str_contains( "Circular dependecy found for ",
        $this->app->extensions->disabledExtensions->{ $ext[3] } );
}

sub test_pluggable_methods {
    my $this = shift;

    $this->_disableAllCurrentExtensions;
    my @ext = $this->_genExtModules(
        3,
        <<'EXT1',
plugBefore 'Foswiki::ExtensionsTests::SampleClass::testPluggableMethod' => sub {
    my $this = shift;
    my ($params) = @_;
    
    # We expect at least to parameters to be passed in.
    $params->{args}[1] = "ext1ArgFromBefore";
};
EXT1
        <<'EXT2',
plugAround 'Foswiki::ExtensionsTests::SampleClass::testPluggableMethod' => sub {
    my $this = shift;
    my ($params) = @_;
    
    # Only if flow control is allowed by the calling test code.
    if ($params->{object}->allowFlowControl) {
        my $rc = 'ext2ReturnFromAround';
        if ( $params->{wantarray} ) {
            $params->{rc} = [$rc];
        }
        elsif ( defined $params->{wantarray} ) {
            $params->{rc} .= ($params->{rc} ? " " : "") . $rc;
        }
        
        delete $params->{ext3Flag1};
        
        Foswiki::Exception::Ext::Last->throw(
                rc => $params->{rc},
                extension => $this,
        );
    }
};

EXT2
        <<'EXT3',
plugBefore 'Foswiki::ExtensionsTests::SampleClass::testPluggableMethod' => sub {
    my $this = shift;
    my ($params) = @_;
    
    $params->{ext3Flag1} = 1;
    $params->{ext3Flag2} = 1;
};

plugAfter 'Foswiki::ExtensionsTests::SampleClass::testPluggableMethod' => sub {
    my $this = shift;
    my ($params) = @_;
    
    foreach my $flag (qw(ext3Flag1 ext3Flag2)) {
        if ($params->{$flag}) {
            my $rc = "with_$flag";
            if ($params->{wantarray}) {
                push @{$params->{rc}}, $rc;
            }
            elsif (defined $params->{wantarray}) {
                $params->{rc} .= " $rc";
            }
        }
    }
};
EXT3
    );
    $this->_setExtDependencies(
        $ext[2] => $ext[1],
        $ext[1] => $ext[0],
    );

    $this->reCreateFoswikiApp;

    my $testClass  = 'Foswiki::ExtensionsTests::SampleClass';
    my $testMethod = 'testPluggableMethod';
    $this->assert(
        defined $Foswiki::Extensions::pluggables{$testClass}{$testMethod},
        "Method "
          . $testMethod
          . " of class "
          . $testClass
          . " is not registered as pluggable!"
    );

    my $testObj = $this->create('Foswiki::ExtensionsTests::SampleClass');

    $this->assert( $testObj->DOES('Foswiki::Aux::_ExtensibleRole'),
            "Test object of class "
          . ref($testObj)
          . " doesn't have extensible role!" );

    my @args;
    @args = qw(arg1 arg2);
    my $rc = $testObj->testPluggableMethod(@args);

    $this->assert_str_equals(
'This is a sample string {arg1}{ext1ArgFromBefore} with_ext3Flag1 with_ext3Flag2',
        $rc
    );

    @args = qw(arg1 arg2);
    my @rc = $testObj->testPluggableMethod(@args);

    $this->assert_deep_equals(
        [
            qw(This is a sample return array arg1 ext1ArgFromBefore with_ext3Flag1 with_ext3Flag2)
        ],
        \@rc
    );

    $testObj->allowFlowControl(1);
    @args = qw(arg1 arg2);
    $rc   = $testObj->testPluggableMethod(@args);

    $this->assert_str_equals( 'ext2ReturnFromAround with_ext3Flag2', $rc );

    @args = qw(arg1 arg2);
    @rc   = $testObj->testPluggableMethod(@args);

    $this->assert_deep_equals( [qw(ext2ReturnFromAround with_ext3Flag2)],
        [@rc] );
}

sub test_API_VERSION {
    my $this = shift;

    $this->_disableAllCurrentExtensions;

    my @ext = $this->_genExtModules(2);
    my $ns0 = Foswiki::getNS( $ext[0] );

    *{ $ns0->{API_VERSION} } = \version->declare("v2.98.0");

    $this->reCreateFoswikiApp;

    ASSERT(
        !$this->app->extensions->extEnabled( $ext[0] ),
        "Extension with API version "
          . Foswiki::fetchGlobal("\$$ext[0]::API_VERSION")
          . " must have been disabled but it's not"
    );

    ASSERT(
        $this->app->extensions->extEnabled( $ext[1] ),
        "Extension with API version "
          . Foswiki::fetchGlobal("\$$ext[1]::API_VERSION")
          . " must have been enabled but it's not"
    );
}

sub test_subClassing {
    my $this = shift;

    $this->_disableAllCurrentExtensions;

    my $configExt = $this->_genExtModules( 1, <<'CFG_EXT');

extClass 'Foswiki::Config' => 'Foswiki::Extension::Sample::Config';
    
CFG_EXT

    $this->reCreateFoswikiApp;

    $this->assert(
        ref( $Foswiki::cfg{'.version'} ) eq 'version',
        "Config key '.version' is expected to be a version object"
    );
    $this->assert_equals(
        $Foswiki::Extension::Sample::Config::VERSION,
        $Foswiki::cfg{'.version'},
        "Config key '.version' returned unexpected version number"
    );

    my $testKey = "_ThisKeyMustNotBeUsed";
    $Foswiki::cfg{$testKey} = my $testVal =
      "Число пі дорівнює 3.1415926";
    $this->assert_equals( $testVal, $this->app->cfg->data->{$testKey},
"Value stored to %Foswiki::cfg doesn't match with fetched from application object cfg attribute"
    );
}

sub test_tag_handlers {
    my $this = shift;

    # Testing three macros registered by the same extension using three
    # different approaches:
    #   1. A macro to be handled by an extension method with the same name as
    #      macro's.
    #   2. Similar to above but method code is declared as tagHandler's second
    #      parameter.
    #   3. A macro class with Foswiki::Macro role.
    # All three are refering the same extension object and it's autoincementing
    # counter attribute. But as long as the first two approaches are extension's
    # methods and rely upon valid $this parameter the class is obtaining
    # extension's object by requesting application's extensions attribute.

    my ($ext) = $this->_genExtModules( 1, <<'TAGH');
    
has counter => (
    is => 'rw',
    lazy => 1,
    default => 0,
);

around counter => sub {
    my $orig = shift;
    my $this = shift;
    my $val = $orig->($this);
    $orig->( $this, $val + 1 );
    return sprintf( '%03d', $val );
};

tagHandler 'TEST_EXT_MACRO1';

tagHandler TEST_EXT_MACRO2 => sub {
    my $this = shift;
    
    return 'TEST_EXT_MACRO2_' . $this->counter;
};

tagHandler TEST_CLASS_MACRO => 'Foswiki::Macros::TEST_CLASS_MACRO';

sub TEST_EXT_MACRO1 {
    my $this = shift;
    return "TEST_EXT_MACRO1_" . $this->counter;
}
TAGH

    my $macroPackage = <<MPKG;
package Foswiki::Macros::TEST_CLASS_MACRO;
    use Foswiki::Class qw(app);
    extends qw(Foswiki::Object);
    with qw(Foswiki::Macro);

    sub expand {
        my \$this = shift;

        my \$myExt = \$this->app->extensions->extObject('$ext');

        return "TEST_CLASS_MACRO_" . \$myExt->counter;
    }
1;
MPKG

    if ( !eval($macroPackage) || $@ ) {
        Foswiki::Exception::Fatal->throw(
            text => "Failed to compile macro class: " . $@ );
    }

    $this->reCreateFoswikiApp;

    $this->test_topicObject->text('%TEST_EXT_MACRO1%');

    $this->assert_str_equals( 'TEST_EXT_MACRO1_000',
        $this->test_topicObject->expandMacros('%TEST_EXT_MACRO1%') );
    $this->assert_str_equals( 'TEST_EXT_MACRO1_001',
        $this->test_topicObject->expandMacros('%TEST_EXT_MACRO1%') );
    $this->assert_str_equals( 'TEST_CLASS_MACRO_002',
        $this->test_topicObject->expandMacros('%TEST_CLASS_MACRO%') );
    $this->assert_str_equals( 'TEST_EXT_MACRO2_003',
        $this->test_topicObject->expandMacros('%TEST_EXT_MACRO2%') );
}

sub test_extName_method {
    my $this = shift;

    my ($ext) = $this->_genExtModules( 1, <<'SNEXT');
our $NAME = "AutoGenExt";
SNEXT

    $this->reCreateFoswikiApp;

    $this->assert_str_equals( 'AutoGenExt',
        $this->app->extensions->extName($ext) );
}

1;
__END__
Foswiki - The Free and Open Source Wiki, http://foswiki.org/

Copyright (C) 2016 Foswiki Contributors. Foswiki Contributors
are listed in the AUTHORS file in the root of this distribution.
NOTE: Please extend that file, not this notice.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version. For
more details read LICENSE in the root of this distribution.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

As per the GPL, removal of this notice is prohibited.
