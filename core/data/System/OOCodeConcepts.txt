%META:TOPICINFO{author="ProjectContributor" date="1507948779" format="1.1" version="1"}%
%META:TOPICPARENT{name="FoswikiV3Essentials"}%
---+ Programming for Foswiki v3
%TOC%

This topic explains basics requirements and specifics of programming for Foswiki
v3. These include:

   * Object oriented techniques
   * Application-centric code
   * Exception handling

It is also implied that the reader of this topic is already familiar with Perl's
OO programming. It is also required to learn about =CPAN:Moo= before proceeding
any further as %WIKITOOLNAME% is using it as the base OO framework.

---++ Basic code requirements

   * Minimal supported Perl version is 5.14 <verbatim>use v5.14;</verbatim>
   * =strict= and =warning= pragmas
   * Use of =CPAN:namespace::clean= (see below)

---++ Object oriented techniques

The first rule of programming for %WIKITOOLNAME% says: "Nobody talks about..."
Er, sorry, that's from another documentation I've being studying recently. ;)

Ok, let's give it a second try:

   : Everything is inheriting from =%PERLDOC{Foswiki::Object}%=.

That's it. You're now ready to go as long as you follow the rule. The rest of
this section is mostly about special features and nuances.

What is so important about inheriting from a single core class? First of all,
it allows for clear separation of Foswiki and non-Foswiki objects by simply
testing 

<verbatim>
if $obj->isa("Foswiki::Object")
</verbatim>

Even if you think this is not important to you – still, it may play significant
role for some core or extension code.

Another important feature of =Foswiki::Object= is its support for debugging and
some object manipulation. For example, it supports object cloning - a very handy
feature; especially for testing framework.

---+++ Construction and desctruction

As required by =Moo=, any object is constructed using named parameters unless
some special care is taken by a class and implemented using =BUILDARGS()=
class method. Otherwise there is nothing special about the default constructor
unless the code is working in =DEBUG= mode (see %PERLDOC{Assert}% and
%PERLDOC{Foswiki::Object}%).

Similar note applies to the destruction stage which usually does nothing unless
the =DEBUG= mode is on. In this case a number of last-second checks is performed
to catch simple errors of bypassing =Moo='s attribute accessors and manipulating
directly on object's hash.

%X% It is highly recommended to avoid using class =new()= method and rely upon
%PERLDOC{"Foswiki::App" method="create"}% instead. 
%PERLDOC{"Foswiki::ExtManager"}% documentation explains the importance of this
rule.

%X% A newly created object is not guaranteed to exist in fully prepared state
as some attributes might still remain uninitialized after construction is done.
See the [[#Attributes][Attributes]] section and keep in mind *lazy* option.

---+++ Attributes

The attributes within Foswiki code are the standard =CPAN:Moo= attributes.
There is a debugging trick implemented by %PERLDOC{Foswiki::Class}%, but it
still doesn't change the default behavior. But there is a convention with
regard to attributes options and their use:

   1 Attributes are named using 
   [[https://en.wikipedia.org/wiki/Camel_case][camelCase]] style, common across
   Foswiki code.
   1 Private attribute names must start with underscore: =_aPrivateAttr=.
   1 Whenever an attribute is utilizing *lazy* option it must be initialized
   with *builder* instead of *default*. The *builder* must define a method
   name which starts with _'prepare'_ followed by attribute name with capitalized
   first character. If attribute is private the leading underscore char must be
   removed and placed in front of _'prepare'_. Here is naming examples:
      $ someAttribute : =prepareSomeAttribute=
      $ !_aPrivateAttribute : =_prepareAPrivateAttribute=

Use of *builder* option is important for class inheritance where descending
class may want to override initialization implementation of its base class.  For
example:

<verbatim class="perl">
package Foswiki::BaseClass;

use Foswiki::Class;
extends qw<Foswiki::Object>

has someAttribute => (
   is   => 'rw',
   lazy => 1,
   builder => 'prepareSomeAttribute',
);

sub prepareSomeAttribute {
    my $this;

    return 1.2;
}

1;
</verbatim>

<verbatim class="perl">
package Foswiki::Descendant;

use Foswiki::Class;
extends qw<Foswiki::BaseClass>;

around prepareSomeAttribute => sub {
    my $orig = shift;
    my $this = shift;

    if ( $someSpecificCondition ) {
        # Under certain circumstances the constant might differ from the default
        return 1.22;
    }

    return $orig->($this);
};

1;
</verbatim>

%X% *NOTE:* It is better to check against the source if certain attribute is
lazy and is using builder. A few lazy ones are still using the *default* option.
This will be fixed over time.

%X% As it is clear from the definition of *lazy* option, attribute remains
uninitialized until referenced. With respect to this fact it is important to
remember that sometimes it is better to use *predicate* option and check if
attribute has been initialized instead of testing if it's _defined_. The latter
may cause unwanted deep recursion if used within *builder* code of another
attribute when the two directly or indirectly depend on each other.

%X% Special care must be taken of attributes storing back references to other
objects. Mostly it is related to situations when a child object is referring its
parent. As this is a typical situation where circular references occur and
cause garbage collection to fail use of *weak_ref* option is highly recommended
to be considered. See %PERLDOC{Foswiki::AppObject}%= role code as an example.

---+++ Avoiding infrastructure code

What would a typical class header look like in Foswiki v3? Lets see how we make
it comply to the base requirements:

<verbatim>
package Foswiki::SomeClass;

use v5.14;
use Moo;
use namespace::clean;
extends qw<Foswiki::Object>;
with qw<Foswiki::AppObject>;
</verbatim>

Though the last line is not mandatory but most of the core classes use it.

So, this is what we would type every time a new class is started. Not only it
takes our priceless time but it may harm our fragile patience. Then, again,
what if we bump the minimal required Perl version? 

In order to get around these annoyances Foswiki provides a wrapper for
=CPAN:Moo= which takes care of this burden:

<verbatim>
package Foswiki::SomeClass;

use Foswiki::Class qw<app>;
extends qw<Foswiki::Object>;
</verbatim>

Minus 3 lines, plus +20 to readability.

There are more useful tricks provided by =%PERLDOC{Foswiki::Class}%=. Read the
module's documentation to find out more about them. Here is just a simple
example:

<verbatim>
package Foswiki::SomeClass;

use Foswiki::Class;
extends qw<Foswiki::Object>;

has attr1 => (
   is      => 'rw',
   lazy    => 1,
   builder => 'prepareAttr1',
);

# This is how it would look previously when prepareAttr1 sub is only a stub
# allowing a descendant to implement the logic:
# sub prepareAttr1 {}

stubMethods qw<prepareAttr1>;
</verbatim>

The example may not look very convincing in its current form with just a single
attribute in use. But simply imagine a number of attributes defined this way.

---+++ Related

=%PERLDOC{Foswiki::Object}%=, =%PERLDOC{Foswiki::Class}%=

---++ Application

Application object is the star of Foswiki's planetary system in a sense that
everything else is rotating around it. The application object is responsible
for:

   1 Creating and initializing other interface objects like extensions and
   configuration managers, engine, request, etc.
   1 Preparing the working environment.
   1 Handling a request if running under a web server.
   1 Providing top-level (or "last resort") exception handlers.

The object is an instance of %PERLDOC{Foswiki::App}% class.

---+++ Foswiki::AppObject role

Internally all Foswiki classes could be separated in two major groups: those
with %PERLDOC{Foswiki::AppObject}% applied; and those without. When a class
consumes the role it means it can exists only within initialized application
environment. Most of the core classes are consuming the role.

The role provides two major elements on a class: 
%PERLDOC{"Foswiki::AppRole" attr="app"}% attribute and =create()= method.

=%PERLDOC{"Foswiki::Class"}%= provides easy way to apply the role:

<verbatim class="perl">
package Foswiki::AppClass;

use Foswiki::Class qw<app>;
extends qw<Foswiki::Object>;
</verbatim>

*NOTE:* There is another role providing support for accessing the application
object. But it is a part of the extensions framework and as such is out of the
scope of this documentation.

%X% *NOTE TO SCRIPT/TOOLS DEVELOPERS:* If a script relies upon a core class
with =Foswiki::AppObject= role applied it must create an application object.
Then either a corresponding attribute on application could be used to do the job
or necessary instance must be created using application's =create()= method.

---+++ $Foswiki::app, $Foswiki::cfg and muli-application environment

It is common for Foswiki code to serve a single request, return a response and
shutdown – all within a single process. In this scenario it is guaranteed that
no more than a single application exists per process.

Things are a little different under PSGI environment which introduces so called
[[https://metacpan.org/pod/PSGI#Delayed-Response-and-Streaming-Body][Delayed \
Response]]. With this technique it is possible that two or more application
objects would share the same address space. Fully compliant with encapsulation
requirements OO code would have no problem with this. But the legacy of older
Foswiki code (especially related to old plugins) makes it necessary for two
global variables to exists which are related to application state rather than
to code state. Those two are
=%PERLDOC{"Foswiki::App" anchor="Legacy_support" text="$Foswiki::app"}%=
(replaces old =$Foswiki::Plugins::SESSION=) and
=%PERLDOC{"Foswiki::Config" anchor="Globals" text="%Foswiki::cfg"}%=.

   : <em>Variables which are related to code state could be found in
   =Foswiki::Class= module, =Foswiki::ExtManager= class and a couple of other
   modules. For example, =%Foswiki::ExtManager::registeredModules= global keeps
   information about all loaded extension modules – the kind of information
   which is only related to what code is currently loaded by Perl.</em>

The problem about the two globals is pretty much clear: they could only be
valid in a non-threaded environment and only if special care is taken to make
them point to corresponding objects responsible for handling currently active
request.

The above statement lead us to inevitable conclusion: *use of these two \
globals is strictly prohibited for the new code*. They're only allowed for
porting legacy plugins to the new codebase.

%X% *NOTE:* PSGI delayed response is not yet implemented and most likely won't
be until Foswiki depends upon the legacy plugins.

---+++ Foswiki API

In versions prior to Foswiki v3 the API was provided by
=%PERLDOC{Foswiki::Func}%= module. Together with migration to fully-OO model the
API definition changes: any public object method is considered an API method
allowed for use by any third-party code.

The new code tries to provide backward compatibility while still allowing pure
data encapsulation. This is done by converting =Foswiki::Func= functions into
%PERLDOC{"Foswiki::App" anchor="API_methods" text="Foswiki::App methods"}%
(except for a couple of them relocated into other, more appropriate classes
– check =%Foswiki::Func::_funcPrefixMap=). Respectively, it is highly
recommended that any code, belonging to a class with =Foswiki::AppObject= role
applied, to use these methods and avoid =Foswiki::Func= whatsoever.

For the legacy code =Foswiki::Func= implements mapping of API functions into API
methods on =$Foswiki::app= global. BTW, for functions declared as deprecated the
mapping code would write a warning into Foswiki log file upon each hundredth
call.

---+++ Related

=%PERLDOC{"Foswiki::App"}%=, =%PERLDOC{"Foswiki::Func"}%=

---++ Exceptions

Comparing to the older Foswiki versions use of exceptions has been extended.
Same time use of =[[CPAN:Error#WARNING][Error]]= has been dropped in favor of
=[[CPAN:Try::Tiny][Try::Tiny]]= and =[[CPAN:Throwable][Throwable]]=.

Things to keep in mind about the exceptions:

   * In addition to basic _throw_ capability Foswiki exceptions introduce 
   _rethrow_ and _transmute_. The former is essentially "throw again" mixed with
   "throw as": it takes an existing exception object, converts it to desired
   class if necessary, and throws again. It is utilizing _transmute_ to do the
   conversion job. See respective methods in =%PERLDOC{Foswiki::Exception}%=.
   * When application is been given control through %PERLDOC{"Foswiki::App"
   method="run"}% method, a handler is installed on =__DIE__= signal which
   rethrows any received exception as =Foswiki::Exception::Fatal=; if =DEBUG= is
   on then any warning becomes an exception too.
   * Any thrown exception tries not only to signal about an event but does its
   best to collect the information about the point in code where it's been
   raised.

---+++ Related

=%PERLDOC{"Foswiki::Exception"}%=

