%META:TOPICINFO{author="ProjectContributor" date="1506731777" format="1.1" version="1"}%
---+!! Spec Files v2.0
%TOC%

This topic is about further development of %WIKITOOLNAME% spec format. Read
about the history and the reasoning behind the specs in
[[Development.HowToWriteASpecFile]]. This document has more focus on specs
supported by %WIKITOOLNAME% v3.

*%X% NOTE:* This document might not be a comprehensive description of the specs and
may require further improvements.

#BasicConcepts
---++ Basic Concepts

Specs v2 are based upon a simple Perl structure of "list of lists". The structure could further 
be extended to higher-level formats if considered reasonable. But for most cases Perl data should
be sufficient. A typical spec file would have the following look:

<verbatim>
#!data
-section => "Extensions" => [
    -section => "DBConfigExtension" => [
        -text => <<EOT,
Database storage backend for LSC
EOT
        "Extensions.DBConfigExtension.Connection" => [
            Host => STRING => [
                -default => 'localhost',
                -label   => 'Database host',
                -text    => 'Where the database server is located',
            ],
            Port => NUMBER => [
                -default => undef,
                -label   => 'Database port',
                -text    => 'Port number where database server is listening',
            ],
            ...,
            EnableSSL => [
                -type => BOOLEAN,
                -default => 1,
                -label   => "DSN",
            ],
        ],
    ],
  ],
</verbatim>

Essentially this is just a Perl array which will be enclosed into square
brackets and fed to =%PERLDOC{"Foswiki::Config" method="spec"}%= method. The
array contains several kinds of elements like section or key definition, etc.

---++ Directories and files.

Lets assume that =FOSWIKI_LIBS= shell environment variable contains the path to
%WIKITOOLNAME% libraries. In this case the following directories are used to
look for spec files:

| *Directory* | *Description* |
| =$FOSWIKI_LIBS= | To load =Foswiki.spec= |
| =$FOSWIKI_LIBS/Foswiki/{Plugins&#124;Contrib&#124;Extension}= | To search\
  for custom spec files. Directories are scanned recursively for files matching\
  =Spec.*= or =*.spec= globs |
| =$FOSWIKI_LIBS/.specCache= | To store specs cached data |

Each file found could contain different spec formats. More about formats is in
[[File Formats]] section. Here it will be explained how the format is determined
for a file:

   1. The file is checked for shebang. Shebang format is a commonly used =#!=
      prefix followed with a format name defined by a single word (see =\w=
      character class in 
      [[https://perldoc.perl.org/perlre.html][Perl regexp documentation]]).
      Example:: <verbatim>#!legacy</verbatim>
   1. If file name is matching =Spec.*= glob then its extension defines the
      format. Example: =Spec.data=
   1. If the file contains TML section formatting string in a =#= comment string
      and a line starting with _$Foswiki::cfg{_ or _1;_ strings then it's format
      would be guessed as legacy.
   1. The default format is data. 

#SpecFormats
---++ File Formats

There're three Spec formats supported out of the box:
   * =data=
   * =perl=
   * =legacy=
   
=data= and =perl= are just variants of specs v2.0. =legacy= is the one used in
pre-%WIKITOOLNAME% v3 era. Sure enough, it is supported for compatibility
matters but its use is discouraged.

   $ =data=: is the basic and the simplest one. Its use is described in the
     [[#BasicConcepts][Basic Concepts]] section.
   $ =perl=: is somewhat more advanced as file content is considered to be
   a body of a method called on a object of a class with
   =%PERLDOC{Foswiki::AppObject}%= and =%PERLDOC{Foswiki::CfgObject}%= roles
   applied. The actual class name is irrelevant and may vary depending on
   implementation. The method will have local scalar =$this= available the code.
   It must return a list with valid spec data. The format is good for
   a situation when some complex processing is necessary before spec data could
   be formed.
   $ =legacy=: pre-%WIKITOOLNAME% v3 format.

---++ Data Format

Spec data is a list of items of different kinds:

   * a option is a item prefixed with dash
   * a string
   * an array ref defining a element body
   * a value of any type possibly following a option.

Elements are the bones of spec body. Currently there are three of them:

   1. Sections
   1. Branch nodes
   1. Leaf nodes

The order of the list defines the order of inclusion. I.e. sections may
contain other sections and branch nodes; branch nodes may contain other
branch nodes and leaf nodes. Leaf nodes only contain values. The example in
the [[#BasicConcepts][Basic Concepts]] section defines a top-level section
_Extensions_, a second level section _DBConfigExtension_, a branch node
_Connection_, and a leaf node _Host_, particularly. Note that it is also
implicitly defines branch nodes _Extensions_ and _DBConfigExtension_ as key
_Extensions.DBConfigExtension.Connection_ gets split into subkeys.

---+++ Section

Sections are a way of grouping configuration settings into logically tied
sets aimed at easing user perception of the configuration. In other words,
a section "Extensions" is expected to contain per-extension config items;
a subsection "Permissions" of "Files" section is about ownership/ACLs applied
to application data files; etc.

A section definition is always started with =-section= option. As a matter
of fact it's the only element defined by a option. It's done this way to
distinguish key definitions from sections within a section body.

The option is then followed by section name string and section body represented
by an array ref:

<verbatim>
-section => "Section Name" => [
    # Section body
    ...
]
</verbatim>

Each section has a level associated with it. There is implicitly defined _Root_
section at level 0. The top-level section (or sections) of any given spec
file correspondingly will be assigned with level 1; any of it's subsections –
level 2; and so on.

Two sections at the same level with same name define the same section as long
as their respective parents define the same section. For example, if there is a
definition:

<verbatim>
-section => "Sec1" => [
    -expert => 1,
    -section => "Sec2" => [
        ...
    ]
]
</verbatim>

and the following is found in another spec file:

<verbatim>
-section => "Sec1" => [
    -section => "Sec2" => [
        ...
    ]
]
</verbatim>

then these are the same section. Note that presence/absence of "-expert"
option doesn't affect this logic. Even more: any subsequent declaration can
change option values defined earlier. This may have some undesirable side
effects and this behavior could change in the future. So far it is advised
to avoid use of any options in a section declaration if it is known to be
declared somewhere else.

As an opposite example to the previous one, the following definitions are
declaring different sections:

<verbatim>
-section => "Sec" => [
    -section => "Sec2" => [
        ...
    ],
],
-section => "Sec1" => [
    -section => "Sec" => [
        -section => "Sec2" => [
            ...
        ]
    ]
]
</verbatim>

_Sec2_ are two new sections here while _Sec1_ is extending _Sec1_ from the
previous two specs.

Note the comma between two =-section= declaration in the latter example.
Remember that this is a Perl list and declaration of _Sec1_ in nothing but
another items in this list.

---+++ Nodes

Nodes are keys in 
%PERLDOC{"Foswiki::Config" attr="data" text="Foswiki::Config data hash"}%.
Depending on their location in the hash tree they fall into two categories:
*branch* and *leaf* nodes.  Branch nodes are those not storing any value but
serving as a container for their sub-nodes. On the contrary, a leaf node is
terminal in a path from top-level node to a value the key represents.

For example, in path _From.Top.To.Bottom_ subkeys _From_, _Top_, and _To_
are branches while _Bottom_ is a leaf node.

A node type could be determined in a few possible ways:

   * If data type or default value is defined for a node – it's a leaf
   * If an option which is either leaf or branch only specific is used - the
     node is of the type for which the option is valid
   * If a sub-key definition detected – it's a branch

Mixing incompatible attributes within single node definition raises a fatal
exception. For example, if a node has type assigned to it and a sub-key
definition is found.

A node declaration can only be found within a section body. The following spec
file is illegal:

<verbatim>
Key => [
    ...
]
</verbatim>

A declaration consist of:

   1. Node name or path
   1. Optional data type
   1. Node body represented by an arrayref

Example of valid keys declarations (the example comes from body of a imaginary
section):

<verbatim>
Key1 => [
    SubKey => [
        -type => 'STRING(30)',
    ],
    "Flags.Key" => [
        -type => "BOOLEAN",
    ],
],
SomeNumber => 'NUMBER(10)' => [
    -default => 3.1415926,
    ...
],
SomeURL => STRING => [
    -default => "http://trygooglethis.com",
    -label => "I don't know what is this for",
    -text => <<EOT,
Let's expect a user to guess what is this value for and how the system is
using it. That'd be fun!
EOT
],
"Full.Key.Path" => PATH => [
    -text => "A key defined by it's full keypath",
],
</verbatim>

Specifying a type or default value implicitly defines a node as a leaf. So, the
following would raise an exception because =SubKey= node cannot have subnodes:

<verbatim>
Key1 => [
    SubKey => [
        -type => 'STRING(30)',
        SubSubKey => [
            ...
        ],
    ],
],
</verbatim>

#ElementOptions
---+++ Options

Sections and key nodes are defined by their attributes defined by options. Both
these basic types share the following options:

| *Name* | *Type* | *Description* |
| =-text= | _string_ | Long element description. Might (and most likely will)\
  be displayed by UI to the user. |
| =-expert= | _flag_ | Marks element as for expert use only. |
| =-source= | varies | Contains information about the source from where the\
  element was read. Usually it's a string with file name but could be a \
  strutrure containing a line number too. |

*%X% NOTE:* _flag_ option type indicates that the option doesn't take a value. It
is boolean and using it in =-option= form means the option is _on_; while
=-nooption= means _off_.

---++++ Section Options

| *Name* | *Type* | *Description* |
| =-modprefix= | _string_ | Prefix part for short module names referred in the\
  section. |
| =-expandable= | _code_ or _string_ | This option defines a subroutine which\
  would generate a list of spec elements which would be inserted right where\
  this option sits. See [[#OptionExpandable][Option -expandable]]. |

#OptionExpandable
---+++++ Option -expandable

=-expandable= could either be a coderef or a string which is expandable's name.
In second case the name is appended to _"Foswiki::Config::Expandable::"_ string
to form a full package name which has to have =compose()= subroutine.

In either form it all ends up with a sub being executed with the following 
parameters passed on to it:

   1 %PERLDOC{Foswiki::Config}% instance most likely to be a content of
     %PERLDOC{"Foswiki::App" attr="cfg"}% attribute
   1 a profile with keys:
      $ section: a %PERLDOC{Foswiki::Config::Section}% instance

As stated above, the code being executed is expected to return a list of spec
elements suitable to be inserted into the section body in place of the
corresponding =-expandable= option.

Examples of working composers code could be found in %WIKITOOLNAME%'s
_lib/Foswiki/Config/Expandable_ directory where currently three standard
modules are located (FINDEXTENSIONS, LANGUAGES, PLUGINS); or in unit test
file _ConfigTests.pm_, =test_expandable()= sub.

---++++ Node options

Most of the key node options are coming from the legacy specs format. For a
while if there is no description for a option then try to find in the old
specs documentation. Meaning of most of them is or will be defined by 
configuration UI code.

| *Name* | *Type* | *Description* |
| =-check= | | |
| =-checker= | | |
| =-check_on_change= | | |
| =-default= | varies | Key's default value. |
| =-display_if= | _string_ |  |
| =-enhance= | _flag_ | Set if enhancing earlier definition of the same key. |
| =-feedback= | | |
| =-hidden= | _flag_ | |
| =-label= | _string_ | Configuration UI input field label text |
| =-onsave= | | |
| =-optional= | _flag_ | |
| =-spellcheck= | | |
| =-type= | _string_ | Type of key's data. |
| =-wizard= | _coderef_ | |

---+++++ Key data types

The following data types are currently supported:

| *Type* | *Attributes* |
| =STRING= | sizeable |
| =NUMBER= | sizeable |
| =URL= | sizeable |
| =URLPATH= | sizeable |
| =REGEX= | sizeable |
| =COMMAND= | sizeable |
| =PASSWORD= | sizeable |
| =PATH= | sizeable |
| =PERL= | sizeable |
| =EMAILADDRESS= | sizeable |
| =SELECT= | drop-down list |
| =SELECTCLASS= | drop-down list |
| =BOOLGROUP= | drop-down list |
| =BOOLEAN= | plain |
| =LANGUAGE= | plain |
| =OCTAL= | plain |
| =DATE= | plain |
| =URILIST= | plain |
| =VOID= | plain |

The attributes above are related to configuration UI:

   $ sizeable: field size with key's value can be limited. The size is defined
     in braces right after the type name: =STRING(80)=
   $ drop-down list: Tells on its own.
   $ plain: Simple field

---++ Related 

=%PERLDOC{Foswiki::Config}%=, =%PERLDOC{Foswiki::Config::DataHash}%=,
=%PERLDOC{Foswiki::Config::Node}%=
